especificarInteresse:
	Variáveis:
		flk_set = Conjunto de folksonomies especificado
		p' = referência ao contexto local do simple-peer
		sp' = referência ao contexto local do super-peer
		spi = referência a um super-peer remoto i
		pi = referência a um peer remoto i
		msgi = referência a mensagem de entrada recebida por um super-peer i
		
	Entrada:
		msgi = nulo
	Ação:
		flk_set = selecionarConjuntoFolksonomies();
		interesse = criarInteresse(tipo, minimum, maximo, flk_set);
		registrarInteresse(interesse);
		
		para todo (spi) in p.listaSuperPeers faça
			inicio
				msgId = gerarMsgId();
				sourceId = p'.id;
				targetId = spi.id;
				ttl = p'.configuracao.ttl;
				hops = 0;
				enviar REQ_REGISTRY_SIMPLE_PEER_INTEREST(msgId, sourceId, targetId, ttl, hops)
			fim
	
	Entrada:
		msgi = 	REQ_REGISTRY_SIMPLE_PEER_INTEREST(msgId, sourceId, targetId, ttl, hops)
	Ação:
		se quantidadeInteresses(sourceId) <= sp'.configuração.numMaxInteresses então
			inicio
				msgId = gerarMsgId();
				sourceId = msgi.targetId;
				targetId = msgi.source;
				ttl = p'.configuracao.ttl;
				hops = 0
				
				enviar REJECT_REGISTRY_SIMPLE_PEER_INTEREST(msgId, sourceId, targetId, ttl, hops);
			fim
		else
			inicio
				msgId = gerarMsgId();
				sourceId = msgi.targetId;
				targetId = msgi.source;
				ttl = p'.configuracao.ttl;
				hops = 0
				
				enviar ACCEPT_REGISTRY_SIMPLE_PEER_INTEREST(msgId, sourceId, targetId, ttl, hops);
			fim
			
	Entrada:
		msgi = ACCEPT_REGISTRY_SIMPLE_PEER(msgId, sourceId, targetId, ttl, hops)
	Ação:
		msgId = gerarMsgId();
		sourceId = msgi.targetId;
		targetId = msgi.source;
		ttl = p'.configuracao.ttl;
		atributos = {'interesses': interesses}
		hops = 0
		
		enviar REGISTRY_SIMPLE_PEER_INTEREST(msgId, sourceId, targetId, ttl, hops, atributos)
	
	Entrada:
		msgi = REGISTRY_SIMPLE_PEER_INTEREST(msgId, sourceId, targetId, ttl, hops, atributos)
	Ação:
		